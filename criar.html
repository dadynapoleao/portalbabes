<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Criar Nova Atriz</title>
    <style>
        /* === COLE EXATAMENTE O MESMO BLOCO CSS DA PÁGINA index.html AQUI === */
        /* Incluindo body, @import, .main-nav, header, etc. */

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #e0e0e0;
            position: relative;
        }

        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

        /* Estilos do Menu (copiados) */
        .main-nav { background-color: #1f1f1f; padding: 0.8em 30px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3); text-align: right; }
        .main-nav ul { list-style: none; margin: 0; padding: 0; }
        .main-nav li { display: inline-block; margin-left: 20px; }
        .main-nav a { color: #e0e0e0; text-decoration: none; font-size: 1.1em; padding: 5px 10px; border-radius: 4px; transition: background-color 0.2s ease, color 0.2s ease; }
        .main-nav a:hover { background-color: #bb86fc; color: #121212; }

        /* Estilos do Header (copiados) */
        header { background-color: #1e1e1e; color: #fff; padding: 2em 0; text-align: center; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); }
        header h1 { margin: 0; font-size: 2.5em; font-weight: 700; letter-spacing: 0.5px; }

        /* Estilos para o Container de Conteúdo */
        .content-container {
            max-width: 1000px; /* Aumentado um pouco para caber mais cards lado a lado */
            margin: 40px auto;
            padding: 30px 40px;
            background-color: #242424;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .content-container h2 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 30px;
            color: #fff;
            font-weight: normal;
        }

        /* --- ESTILOS DO FORMULÁRIO COM CARDS --- */

        /* Container Flex para os cards (o próprio form) */
        #create-actress-form {
            display: flex; /* Ativa o Flexbox */
            flex-wrap: wrap; /* Permite que os itens quebrem para a próxima linha */
            gap: 16px; /* Espaço entre os cards */
            margin-bottom: 30px; /* Espaço antes do botão de submit */
        }

        /* Estilo do Card Individual (era .form-group) */
        .form-card {
            background-color: #333; /* Fundo do card */
            padding: 18px; /* Espaçamento interno do card */
            border-radius: 8px; /* Bordas arredondadas */
            border: 1px solid #444; /* Borda sutil */
            /* Controle de Largura: flex-basis define o tamanho base, grow/shrink permitem ajuste */
            flex-basis: calc(50% - 8px); /* Base para 2 colunas (50% menos metade do gap) */
            flex-grow: 1; /* Permite que o card cresça se houver espaço */
            box-sizing: border-box; /* Padding e borda incluídos na largura/altura */
            min-width: 250px; /* Largura mínima para evitar cards muito estreitos */
        }

        /* Card de Largura Total (para Textarea, por exemplo) */
        .form-card.full-width {
            flex-basis: 100%; /* Ocupa a largura total */
        }


        .content-container label {
             display: block;
             margin-bottom: 10px; /* Espaço maior abaixo do label */
             color: #b0b0b0;
             font-size: 0.9em; /* Label ligeiramente menor */
             font-weight: bold;
         }

         /* Inputs e Textarea dentro dos cards */
         .content-container input[type="text"],
         .content-container input[type="url"],
         .content-container input[type="number"],
         .content-container textarea {
             width: 100%;
             padding: 10px 12px; /* Padding interno dos inputs */
             background-color: #404040; /* Fundo do input ligeiramente diferente do card */
             border: 1px solid #555;
             border-radius: 5px;
             color: #e0e0e0;
             box-sizing: border-box;
             font-size: 1em;
             transition: border-color 0.2s ease, box-shadow 0.2s ease;
             margin-bottom: 0; /* Remover margem inferior do input, espaço é controlado pelo card/gap */
         }

         .content-container textarea {
             min-height: 120px;
             resize: vertical;
         }


         .content-container input:focus,
         .content-container textarea:focus {
            outline: none;
            border-color: #bb86fc;
            box-shadow: 0 0 0 3px rgba(187, 134, 252, 0.3);
         }

         /* Botão de Submit (fora do flex container dos cards) */
         .submit-button-container {
             text-align: center; /* Centraliza o botão se ele não for 100% */
         }
         .content-container button[type="submit"] {
             /* display: block; */ /* Pode ser inline-block ou block */
             /* width: 100%; */ /* Opcional: largura total ou auto? */
             min-width: 200px; /* Largura mínima */
             margin-top: 10px; /* Ajuste conforme necessário */
             background-color: #bb86fc;
             color: #121212;
             padding: 14px 35px; /* Padding generoso */
             border: none;
             border-radius: 6px;
             font-size: 1.2em;
             font-weight: bold;
             cursor: pointer;
             transition: background-color 0.2s ease, transform 0.1s ease;
         }
         .content-container button[type="submit"]:hover {
             background-color: #a772e3;
         }
         .content-container button[type="submit"]:active {
             transform: scale(0.98);
         }

        /* --- FIM DOS ESTILOS DO FORMULÁRIO COM CARDS --- */
    </style>
</head>
<body>

    <!-- MENU DE NAVEGAÇÃO -->
    <nav class="main-nav">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="criar.html">Criar</a></li>
        </ul>
    </nav>
    <!-- FIM MENU -->

    <header>
        <h1>Criar Nova Atriz</h1>
    </header>

    <!-- ÁREA DE CONTEÚDO PRINCIPAL -->
    <main>
        <div class="content-container">
            <h2>Adicionar Nova Atriz</h2>

            <!-- FORMULÁRIO DE CRIAÇÃO - AGORA UM FLEX CONTAINER -->
            <form id="create-actress-form">

                <!-- Card para Nome -->
                <div class="form-card">
                    <label for="name">Name:</label>
                    <input type="text" id="name" name="name" required>
                </div>

                <!-- Card para Foto (NOVO) -->
                <div class="form-card">
                    <label for="foto">Foto (URL):</label>
                    <input type="url" id="foto" name="foto" placeholder="https://exemplo.com/imagem.jpg" required>
                </div>

                 <!-- Card para Texto/Biografia (Largura Total) -->
                <div class="form-card full-width">
                    <label for="texto">Texto (Biografia/Descrição):</label>
                    <textarea id="texto" name="texto" rows="5" placeholder="Cole ou digite a biografia e informações aqui..." required></textarea>
                </div>

                <!-- Card para Born -->
                <div class="form-card">
                    <label for="born">Born (Ex: 1990-05-15):</label>
                    <input type="text" id="born" name="born" placeholder="YYYY-MM-DD">
                </div>

                <!-- Card para Birthplace -->
                <div class="form-card">
                    <label for="birthplace">Birthplace:</label>
                    <input type="text" id="birthplace" name="birthplace">
                </div>

                <!-- Card para Ethnicity -->
                <div class="form-card">
                    <label for="ethnicity">Ethnicity:</label>
                    <input type="text" id="ethnicity" name="ethnicity">
                </div>

                <!-- Card para Hair color -->
                <div class="form-card">
                    <label for="hair_color">Hair color:</label>
                    <input type="text" id="hair_color" name="hair_color">
                </div>

                <!-- Card para Eye color -->
                <div class="form-card">
                    <label for="eye_color">Eye color:</label>
                    <input type="text" id="eye_color" name="eye_color">
                </div>

                <!-- Card para Height -->
                <div class="form-card">
                    <label for="height">Height (Ex: 170 cm):</label>
                    <input type="text" id="height" name="height">
                </div>

                <!-- Card para Weight -->
                <div class="form-card">
                    <label for="weight">Weight (Ex: 59 kg):</label>
                    <input type="text" id="weight" name="weight">
                </div>

                <!-- Card para Body type -->
                <div class="form-card">
                    <label for="body_type">Body type:</label>
                    <input type="text" id="body_type" name="body_type">
                </div>

                <!-- Card para Measurements -->
                <div class="form-card">
                    <label for="measurements">Measurements (Ex: 34-24-35):</label>
                    <input type="text" id="measurements" name="measurements">
                </div>

                <!-- Card para Years active -->
                <div class="form-card">
                    <label for="years_active">Years active (Ex: 2010-present):</label>
                    <input type="text" id="years_active" name="years_active">
                </div>

                <!-- Card para Nota (NOVO) -->
                 <div class="form-card">
                    <label for="nota">Nota (0 a 10):</label>
                    <input type="number" id="nota" name="nota" min="0" max="10" step="0.1" placeholder="Ex: 8.5">
                </div>

            </form>
            <!-- FIM DO FORMULÁRIO (FLEX CONTAINER) -->

            <!-- CONTAINER PARA O BOTÃO (Fora do form flex) -->
            <div class="submit-button-container">
                <button type="submit" form="create-actress-form">Criar</button>
            </div>

        </div>
    </main>
    <!-- FIM ÁREA DE CONTEÚDO -->

    <!-- Script para lidar com o envio do formulário -->
<script type="module">
    // Import Firebase functions
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    // Import Firestore functions needed for query and write
    import { getFirestore, collection, addDoc, query, where, getDocs, limit, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    // Your web app's Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBZEffPMXgbSHYUUrNdIS5duAVGlKlmSq0", // IMPORTANT: Consider securing this key
      authDomain: "babes-392fd.firebaseapp.com",
      projectId: "babes-392fd",
      storageBucket: "babes-392fd.appspot.com",
      messagingSenderId: "376795361631",
      appId: "1:376795361631:web:d662f2b2f2cd23b115c6ea"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // --- ELEMENTOS DO DOM ---
    const form = document.getElementById('create-actress-form');
    const submitButton = document.querySelector('button[form="create-actress-form"]');
    const sourceTextArea = document.getElementById('texto');
    const nameInput = document.getElementById('name');
    // ADDED: Get the error message element
    const nameErrorMessage = document.getElementById('name-error-message');

    // --- MAPEAMENTO: ID do Formulário -> Nome do Campo no Firestore ---
    const firestoreFieldMap = {
        'name': 'nome',
        'texto': 'texto',
        'foto': 'foto',
        'born': 'dataNascimento',
        'birthplace': 'pais',
        'ethnicity': 'etnia',
        'hair_color': 'corCabelo',
        'eye_color': 'corOlhos',
        'height': 'altura',
        'weight': 'peso',
        'body_type': 'tipoCorpo',
        'measurements': 'medidas',
        'years_active': 'AnosAtiva',
        'nota': 'nota'
    };

    // --- FUNÇÕES HELPER PARA FORMATAÇÃO ---
    // (Keep your existing formatBornDate, extractCmValue, etc. functions here)
    // ... (your existing helper functions) ...
    function formatBornDate(dateString) { // Example - keep all helpers
        const dateRegex = /(\d{1,2})(?:st|nd|rd|th)?\s+(?:of\s+)?([a-zA-Z]+)\s+(\d{4})/;
        const match = dateString.match(dateRegex);
        if (match) {
            const day = match[1].padStart(2, '0');
            const monthName = match[2];
            const year = match[3];
            const monthMap = {'january': '01', 'february': '02', 'march': '03', 'april': '04', 'may': '05', 'june': '06', 'july': '07', 'august': '08', 'september': '09', 'october': '10', 'november': '11', 'december': '12'};
            const monthNumber = monthMap[monthName.toLowerCase()];
            if (monthNumber) return `${year}/${monthNumber}/${day}`;
            else console.warn(`Mês não reconhecido: "${monthName}"`);
        } else {
            console.warn(`Formato de data não reconhecido: "${dateString}"`);
        }
        return dateString;
    }
    function extractCmValue(heightString) {
        const cmRegex = /\(\s*(?:or\s+)?(\d+)\s*cm\s*\)/i;
        const match = heightString.match(cmRegex);
        return match ? match[1] : '';
    }
    function extractKgValue(weightString) {
        const kgRegex = /\(\s*(?:or\s+)?(\d+)\s*kg\s*\)/i;
        const match = weightString.match(kgRegex);
        return match ? match[1] : '';
    }
    function extractStartYear(yearsString) {
        const yearRegex = /(\d{4})/;
        const match = yearsString.match(yearRegex);
        return match ? match[1] : '';
    }


    // --- FUNÇÃO PRINCIPAL DE AUTO-PREENCHIMENTO ---
    function autoFillForm() {
       // ... (your existing autoFillForm function - no changes needed here) ...
        if (!sourceTextArea) return;
        const textContent = sourceTextArea.value;
        const lines = textContent.split('\n');
        // Limpeza
        // Don't clear name if user is typing in it for the check
        // if(nameInput) nameInput.value = '';

        const fieldMappingsForAutofill = {
            'Born': 'dataNascimento', 'Birthplace': 'pais', 'Ethnicity': 'etnia',
            'Hair color': 'corCabelo', 'Eye color': 'corOlhos', 'Height': 'altura',
            'Weight': 'peso', 'Body type': 'tipoCorpo', 'Measurements': 'medidas',
            'Years active': 'AnosAtiva'
         };
         // Limpa campos mapeados (exceto texto/nome/foto/nota)
         Object.keys(firestoreFieldMap).forEach(formId => {
             if(formId === 'texto' || formId === 'name' || formId === 'foto' || formId === 'nota') return;
             const inputElement = document.getElementById(formId);
             if (inputElement) inputElement.value = '';
         });

        // Preenche Nome se ainda não foi preenchido pelo usuário
        if (lines.length > 0 && nameInput && !nameInput.value) nameInput.value = lines[0].trim();

        // Outros campos
         Object.entries(fieldMappingsForAutofill).forEach(([label, firestoreKey]) => {
             const formId = Object.keys(firestoreFieldMap).find(key => firestoreFieldMap[key] === firestoreKey);
             if(!formId) return;

             const regex = new RegExp(`^${label}:\\s*(.*)$`, 'im');
             const match = textContent.match(regex);
             if (match) {
                 let value = match[1].trim();
                 // Formatação
                 if (firestoreKey === 'dataNascimento') value = formatBornDate(value);
                 else if (firestoreKey === 'altura') value = extractCmValue(value);
                 else if (firestoreKey === 'peso') value = extractKgValue(value);
                 else if (firestoreKey === 'AnosAtiva') value = extractStartYear(value);
                 // Preenchimento
                 const inputElement = document.getElementById(formId);
                 // Only fill if the field is empty, don't overwrite user input
                 if (inputElement && !inputElement.value) inputElement.value = value;
                 else if (!inputElement) console.warn(`Elemento de formulário com ID "${formId}" não encontrado para ${firestoreKey}`);
             }
         });
    }

    // --- ADDED: Debounce function ---
    function debounce(func, delay) {
      let timeoutId;
      return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          func.apply(this, args);
        }, delay);
      };
    }

    // --- ADDED: Function to check if name exists in Firestore ---
    async function checkNameExists() {
        if (!nameInput || !nameErrorMessage || !db) return; // Safety checks

        const enteredName = nameInput.value.trim();

        // Hide message initially or if name is empty
        nameErrorMessage.style.display = 'none';
        nameErrorMessage.textContent = '';
        // Re-enable submit button by default when checking (will be disabled below if needed)
        if (submitButton) submitButton.disabled = false;


        if (enteredName === '') {
            return; // Don't query if the name field is empty
        }

        // Disable submit button while checking
        if (submitButton) submitButton.disabled = true;


        try {
            // console.log(`Checking Firestore for name: "${enteredName}"`); // Optional: for debugging
            const checkQuery = query(collection(db, "atores"), where("nome", "==", enteredName), limit(1));
            const querySnapshot = await getDocs(checkQuery);

            if (!querySnapshot.empty) {
                // Name exists! Show the error message.
                nameErrorMessage.textContent = `O nome "${enteredName}" já existe.`;
                nameErrorMessage.style.display = 'block';
                // Keep submit button disabled because name exists
                if (submitButton) submitButton.disabled = true;
            } else {
                // Name does not exist, message remains hidden.
                // Enable submit button if the check passed
                if (submitButton) submitButton.disabled = false;
            }
        } catch (error) {
            console.error("Erro ao verificar nome no Firestore:", error);
            nameErrorMessage.textContent = 'Erro ao verificar o nome. Tente novamente.';
            nameErrorMessage.style.display = 'block';
            // Keep submit button disabled on error
             if (submitButton) submitButton.disabled = true;
        }
    }

    // --- EVENT LISTENERS ---
    if (sourceTextArea) {
        sourceTextArea.addEventListener('input', autoFillForm);
    }

    // ADDED: Listener for the Name input field (with debounce)
    if (nameInput) {
        // Debounce the check function: wait 500ms after user stops typing
        const debouncedCheck = debounce(checkNameExists, 500);
        nameInput.addEventListener('input', debouncedCheck);
         // Optional: also check when the user leaves the field
        nameInput.addEventListener('blur', checkNameExists);
    }


    // Listener para o envio do formulário
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!submitButton) return;

        // --- Submission logic might need adjustment ---
        // The real-time check might already disable the button.
        // However, we still perform a final check here as a safeguard.

        const initialButtonText = 'Criar'; // Store initial text
        submitButton.disabled = true; // Disable immediately
        submitButton.textContent = 'Verificando...';

        const formData = new FormData(form);
        const enteredName = formData.get('name')?.trim();

        if (!enteredName) {
            alert('O campo "Nome" é obrigatório.');
            submitButton.disabled = false;
            submitButton.textContent = initialButtonText;
            return;
        }

        // --- FINAL CHECK before saving (redundant if real-time check worked, but safe) ---
        try {
            const checkQuery = query(collection(db, "atores"), where("nome", "==", enteredName), limit(1));
            const querySnapshot = await getDocs(checkQuery);

            if (!querySnapshot.empty) {
                // Update the persistent error message as well
                if(nameErrorMessage) {
                    nameErrorMessage.textContent = `O nome "${enteredName}" já existe.`;
                    nameErrorMessage.style.display = 'block';
                }
                alert(`Já existe uma atriz com o nome "${enteredName}". Não é possível criar duplicados.`);
                // Keep button disabled as the name exists
                submitButton.disabled = true; // Explicitly keep disabled
                submitButton.textContent = initialButtonText; // Reset text but keep disabled
                return; // Stop the submission process
            }
            // --- End of Final Check ---

            // Name does not exist (or check passed), proceed to save
            submitButton.textContent = 'Salvando...';

            const firestoreData = {};
            // Build firestoreData object (your existing logic is fine)
             for (const [formId, firestoreKey] of Object.entries(firestoreFieldMap)) {
                const rawValue = formData.get(formId);
                if (rawValue !== null && rawValue !== undefined) {
                    const trimmedValue = typeof rawValue === 'string' ? rawValue.trim() : rawValue;
                    if (trimmedValue === '' && firestoreKey !== 'nota') continue;

                    if (formId === 'nota') {
                        const numValue = parseFloat(trimmedValue);
                        if (!isNaN(numValue)) firestoreData[firestoreKey] = numValue;
                    } else if (formId === 'measurements') {
                        firestoreData[firestoreKey] = trimmedValue;
                        const parts = trimmedValue.split('-');
                        if (parts.length === 3) {
                            firestoreData['Boobs'] = parts[0].trim();
                            firestoreData['Waist'] = parts[1].trim();
                            firestoreData['Ass'] = parts[2].trim();
                        } else {
                             console.warn(`Medidas não divididas: "${trimmedValue}"`);
                        }
                    } else {
                        firestoreData[firestoreKey] = trimmedValue;
                    }
                }
            }
            firestoreData.createdAt = serverTimestamp();

            console.log('Dados a serem enviados para Firestore:', firestoreData);

            // Save to Firestore
            const docRef = await addDoc(collection(db, "atores"), firestoreData);
            console.log("Documento escrito com ID: ", docRef.id);
            alert('Atriz criada com sucesso!');
            form.reset();
            // Clear any lingering error message after successful submission
            if (nameErrorMessage) {
                nameErrorMessage.style.display = 'none';
                nameErrorMessage.textContent = '';
            }


        } catch (error) {
            console.error("Erro durante o processo de criação: ", error);
            alert(`Erro: ${error.message}. Verifique o console.`);
            // Keep button disabled on error? Or enable? User choice. Let's enable.
             submitButton.disabled = false;

        } finally {
            // Careful here: only re-enable if no error *or* if error wasn't 'duplicate'
            // The logic above handles enabling/disabling more specifically.
            // If the button is still disabled at this point (e.g., due to duplicate found),
            // DON'T re-enable it unconditionally.
            // So, we adjust the enable/disable within the try/catch blocks.
            // We'll just ensure the text is reset if it wasn't successful.
             if (submitButton.textContent.includes('Salvando...') || submitButton.textContent.includes('Verificando...')) {
                submitButton.textContent = initialButtonText;
             }
             // Final check: If the name field still shows an error, keep the button disabled
             if (nameErrorMessage && nameErrorMessage.style.display === 'block') {
                 if(submitButton) submitButton.disabled = true;
             } else {
                 // If no error is displayed, ensure button is enabled (unless saving failed for other reasons)
                 // This might conflict slightly, let's rely on the specific enable/disable in try/catch
             }
        }
    });

</script>
</body>
</html>
